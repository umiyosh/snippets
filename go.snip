snippet golang
	package main
	import (
		"${1:package}"
	)
	func main(${2}) {
		${3}
	}
# shorthand variable declaration
snippet v
	${1} := ${2}
# variable initialization
snippet vr
	var ${1:t} ${0:string}
# variable declaration
snippet var
abbr var x Type [= ...]
	var ${1:x} ${2:Type}${3: = ${0:value\}}
# variables declaration
snippet vars
abbr var ( ... )
	var (
		${1:x} ${2:Type}${3: = ${0:value\}}
	)
# append
snippet ap
abbr append(slice, value)
	append(${1:slice}, ${0:value})
# append assign
snippet ap=
abbr slice = append(slice, value)
  ${1:slice} = append($1, ${0:value})
# bool
snippet bl
	bool
# byte
snippet bt
	byte
# break
snippet br
	break
# channel
snippet ch
abbr chan Type
	chan ${0:int}
# case
snippet case
abbr case ...:
	case ${1:value}:
		${0}
# default case
snippet default
abbr default: ...
	default:
		${0}
# constant
snippet const
alias con
abbr const XXX Type = ...
	const ${1:NAME} ${2:Type} = ${0:0}
# constants
snippet constt
alias cons
abbr const ( ... )
	const (
		${1:NAME} ${2:Type} = ${3:value}
		${0}
	)
# constants with iota
snippet iota
abbr const ( ... = iota )
	const (
		${1:NAME} ${2:Type} = iota
		${0}
	)
# continue
snippet cn
abbr continue
	continue
# defer
snippet defer
abbr defer someFunction()
	defer ${1:func}(${2})
	${0}
snippet deff
abbr defer func() { ... }
	defer func() {
		${0}
	}()
# defer recover
snippet defr
	defer func() {
		if err := recover(); err != nil {
			${0}
		}
	}()

# int
snippet i
	int
# import
snippet import
abbr import ( ... )
	import (
		"${1:package}"
	)
# interface
snippet in
	interface{}
# full interface snippet
snippet interface
abbr interface I { ... }
	type ${1:Interface} interface {
		${2:/* TODO: add methods */}
	}
# if condition
snippet if
abbr if ... { ... }
	if ${1:condition} {
		${0}
	}
# else snippet
abbr else { ... }
snippet else
	else {
		${0}
	}
snippet ifn
	if err != nil {
		${1}
		return err
	}
# else snippet
snippet el
	else {
		${1}
	}
# if else
snippet ife
	if ${1:/* condition */} {
		${2}
	} else {
		${3}
	}
	${0}
snippet ifee
	if ${1:/* condition1 */} {
		${2}
	} else if ${3:/* condition2 */} {
		${4}
	} else {
		${5}
	}
	${0}
# if inline error
snippet ifn
abbr if err := ...; err != nil { ... }
	if err := ${1:condition}; err != nil {
		${0}
	}
# error snippet
snippet ifnr
abbr if err != nil { return err }
	if err != nil {
		return err
	}
	${0}
# error snippet in TestFunc
snippet ifnt
abbr if err != nil { t.Fatal(err) }
	if err != nil {
		t.Fatal(err)
	}
# error snippet in log.Fatal
snippet ifnl
abbr if err != nil { log.Fatal(err) }
	if err != nil {
		log.Fatal(err)
	}
# error snippet with two return values
snippet ifnr,
abbr if err != nil { return [...], err }
	if err != nil {
		return ${1:nil}, err
	}
	${0}
# error snippet handle and return
snippet ifr
abbr if err != nil { ... return }
	if err != nil {
		${1}
		return
	}
	${0}
# error snippet with panic
snippet ifp
abbr if err != nil { panic(...) }
	if err != nil {
		panic(${1})
	}
	${0}
snippet ifok
abbr if !ok { ... }
	if !ok {
		${0}
	}
# false
snippet f
	false
# fallthrough
snippet ft
	fallthrough
# float
snippet fl
	float32
# float32
snippet f3
	float32
# float64
snippet f6
	float64
# for loop
snippet for
abbr for ... { ... }
	for ${1} {
		${0}
	}
# for integer loop
snippet fori
abbr for 0..N-1 { ... }
	for ${1:i} := 0; $1 < ${2:N}; $1++ {
		${0}
	}
# for range loop
snippet fore
abbr for k, v := range items { ... }
	for ${2:k}, ${3:v} := range ${1} {
		${0}
	}
# function simple
snippet func
abbr func function(...) [error] { ... }
	func ${1:function}(${2}) ${3:error }{
		${0}
	}

# function on receiver
snippet funcm
abbr func (...) function(...) [error] { ... }
	func (${1:receiver} ${2:type}) ${3:funcName}(${4}) ${5:error} {
		${6}
	}
	${0}
# anonymous function
snippet anon
abbr fn := func() { ... }
	${1:fn} := func() {
		${0}
	}
# print
snippet fmtpf
abbr fmt.Printf(...)
	fmt.Printf("%${1:s}\n", ${2:var})
# Fmt Println debug
snippet fmtpl
abbr fmt.Println(...)
	fmt.Println(${1})
snippet fmtp
abbr fmt.Print(...)
	fmt.Print(${1})
# Fmt Errorf
snippet fmterr
abbr fmt.Errorf(...)
	fmt.Errorf(${1})
snippet fmtsp
alias sp
abbr fmt.Sprintf(...)
	fmt.Sprintf("%${1:s}", ${2:var})
# log printf
snippet logf
abbr log.Printf(...)
	log.Printf("${1} = %+v\n", $1)
# log println
snippet logl
abbr log.Println(...)
	log.Println(${1})
# make
snippet make
abbr make(Type, size)
	make(${1:[]string}, ${2:0})${0}
# makemap
snippet makemap
abbr make(Type, size)
	make(map[${1:string}]${0:int}, ${3:0})${4}
# makechan
snippet makechan
abbr makechan
	make(chan ${0:int}${1:, size})
snippet map
abbr map[Type]Type
	map[${1:string}]${0:int}
snippet main
abbr func main() { ... }
options head
	func main() {
		${0}
	}
# new
snippet nw
	new(${0:type})
# package
snippet package
abbr package ...
	package ${1:main}
	${0}
# panic
snippet panic
alias pn
abbr panic("...")
	panic("${0:msg}")
# range
snippet rn
	range ${0}
# return
snippet return
alias rt
abbr return ...
	return ${0}
# result
snippet rs
	result
# select
snippet select
alias sl
abbr select { case a := <-chan: ... }
	select {
	case ${1:v1} := <-${2:chan1}
		${3}
	case ${4:v2} := <-${5:chan2}
		${6}
	default:
		${0}
	}
# string
snippet sr
	string
# struct
snippet type
abbr type T struct { ... }
	type ${1:Type} struct {
		${0}
	}
snippet struct
	${1:name} struct {
		${2:/* data */}
	}
	${0}
# switch
snippet switch
abbr switch x { ... }
	switch ${1:var} {
	case ${2:value1}:
		${3}
	case ${4:value2}:
		${5}
	default:
		${0}
	}
# true
snippet t
	true
# goroutine named function
snippet go
abbr go someFunc(...)
	go ${1:funcName}(${0})
# goroutine anonymous function
snippet gof
abbr go func(...) { ... }(...)
	go func(${1} ${2:type}) {
		${3:/* code */}
	}(${0})
snippet test
abbr func TestXYZ(t *testing.T) { ... }
	func Test${1:name}(t *testing.T) {
		${2}
	}
	${0}
# test error
snippet testerr
alias ter
abbr if err != nil { t.Errorf(...) }
  if err != nil {
    t.Errorf("${1}")
  }
# test fatal error
snippet testfatal
alias terf
abbr if err != nil { t.Fatalf(...) }
  if err != nil {
    t.Fatalf("${1}")
  }
# test server
snippet testserver
snippet tsrv
abbr ts := httptest.NewServer(...)
  ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintln(w, ${1:`response`})
  }))
  defer ts.Close()

  //Use testing server url (type string) somewhere
  ${0:someUrl} = ts.URL
# test benchmark
snippet benchmark
	func Benchmark${1:Method}(b *testing.B) {
		for i := 0; i < b.N; i++ {
			${0}
		}
	}
# json snippet
snippet json
abbr \`json:key\`
	\`json:"${1:keyName}"\`
# yaml snippet
snippet yaml
abbr \`yaml:key\`
	\`yaml:"${1:keyName}"\`

snippet hf
abbr http.HandlerFunc
  func ${1:handler}(w http.ResponseWriter, r *http.Request) {
    ${0:fmt.Fprintf(w, "hello world")}
  }

snippet hhf
abbr mux.HandleFunc(...)
  ${1:http}.HandleFunc("${2:/}", func(w http.ResponseWriter, r *http.Request) {
    ${0:fmt.Fprintf(w, "hello world")}
  })

# -----------------------------
snippet open
abbr file, err := os.Open(...) ...
	${2:file}, err := os.Open("${1}")
	defer $2.Close()
	if err != nil {
		panic(err)
	}

snippet bufioreadstring
alias bufst
abbr reader := bufio.NewReader(...) ...
	${2:reader} := bufio.NewReader(${1:file})
	for {
		${:buf}, err := $2.ReadString(${3:'\n'})
		if err != nil {
			if err == io.EOF || err == io.ErrClosedPipe {
				break
			}
			panic(err)
		}
	}

snippet bufioscan
alias bufsc
abbr reader := bufio.NewScanner(...) ...
	${2:scanner} := bufio.NewScanner(${1:file})
	for $2.Scan() {
		fmt.Print($2.Text())
	}
	if $2.Err() != nil {
		panic($2.Err())
	}

snippet csvread
alias csvr
abbr reader := csv.NewReader(...) ...
	${2:reader} := csv.NewReader(${1:file})
	reader.Comma = ${3:'\t'}
	reader.LazyQuotes = ${4:true}
	for {
		${5:record}, err := $2.Read()
		if err == io.EOF {
			break
		} else if err != nil {
			panic(err)
		}
	}

