snippet golang
	package main
	import (
		"${1:package}"
	)
	func main(${2}) {
		${3}
	}
# shorthand variable declaration
snippet v
	${1} := ${2}
# variable initialization
snippet vr
	var ${1:t} ${0:string}
# variable declaration
snippet var
	var ${1} ${2} = ${3}
# variables declaration
snippet vars
	var (
		${1} ${2} = ${3}
	)
# append
snippet ap
abbr append(slice, value)
	append(${1:slice}, ${0:value})
# append assign
snippet ap=
abbr slice = append(slice, value)
  ${1:slice} = append($1, ${0:value})
# bool
snippet bl
	bool
# byte
snippet bt
	byte
# break
snippet br
	break
# channel
snippet ch
abbr chan Type
	chan ${0:int}
# case
snippet case
abbr case ...:
	case ${1:value}:
		${0}
# constant
snippet con
abbr const XXX Type = ...
	const ${1:NAME} ${2:Type} = ${0:0}
# constants
snippet cons
abbr const ( ... )
	const (
		${1:NAME} ${2:Type} = ${3:value}
		${0}
	)
# constants with iota
snippet iota
abbr const ( ... = iota )
	const (
		${1:NAME} ${2:Type} = iota
		${0}
	)
# continue
snippet cn
abbr continue
	continue
# defer
snippet df
	defer ${0:func}()
# defer recover
snippet dfr
	defer func() {
		if err := recover(); err != nil {
			${0}
		}
	}()
# gpl
snippet gpl
	/*
	 * This program is free software; you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation; either version 2 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU General Public License
	 * along with this program; if not, see <http://www.gnu.org/licenses/>.
	 *
	 * Copyright (C) ${1:Author}, `strftime("%Y")`
	 */

	${0}
# int
snippet i
	int
# import
snippet import
	import (
		"${1:package}"
	)
# interface
snippet in
	interface{}
# full interface snippet
snippet inf
	interface ${1:name} {
		${2:/* methods */}
	}
# if condition
snippet if
	if ${1:/* condition */} {
		${2}
	}
snippet ifn
	if err != nil {
		${1}
		return err
	}
# else snippet
snippet el
	else {
		${1}
	}
# error snippet
snippet ir
	if err != nil {
		return err
	}
	${0}
# false
snippet f
	false
# fallthrough
snippet ft
	fallthrough
# float
snippet fl
	float32
# float32
snippet f3
	float32
# float64
snippet f6
	float64
# if else
snippet ife
	if ${1:/* condition */} {
		${2}
	} else {
		${3}
	}
	${0}
snippet ifee
	if ${1:/* condition1 */} {
		${2}
	} else if ${3:/* condition2 */} {
		${4}
	} else {
		${5}
	}
	${0}
# for loop
snippet for
	for ${2:i} := 0; $2 < ${1:count}; $2${3:++} {
		${4}
	}
	${0}
# for range loop
snippet fore
	for ${1:k}, ${2:v} := range ${3} {
		${4}
	}
	${0}
# function simple
snippet func
	func ${1:funcName}( ${2} ) ${3:error} {
		${4}
	}

# function on receiver
snippet funcm
	func (${1:receiver} ${2:type}) ${3:funcName}(${4}) ${5:error} {
		${6}
	}
	${0}
# anonymous function
snippet anon
abbr fn := func() { ... }
	${1:fn} := func() {
		${0}
	}
# log printf
snippet lf
	log.Printf("%${1:s}", ${2:var})
# log printf
snippet lp
	log.Println("${1}")
# make
snippet mk
	make(${1:[]string}, ${0:0})
# map
snippet mp
	map[${1:string}]${0:int}
# main()
snippet funcmain
	func main() {
		${1}
	}
	${0}
# new
snippet nw
	new(${0:type})
# package
snippet package
	package ${1:main}
# panic
snippet pn
	panic("${0:msg}")
# print
snippet print
	fmt.Printf("%${1:s}\n", ${2:var})
# range
snippet rn
	range ${0}
# return
snippet rt
	return ${0}
# result
snippet rs
	result
# select
snippet sl
	select {
	case ${1:v1} := <-${2:chan1}
		${3}
	case ${4:v2} := <-${5:chan2}
		${6}
	default:
		${0}
	}
# string
snippet sr
	string
# struct
snippet type
	type ${1:name} struct {
		${2:/* data */}
	}
	${0}
snippet struct
	${1:name} struct {
		${2:/* data */}
	}
	${0}
# switch
snippet switch
	switch ${1:var} {
	case ${2:value1}:
		${3}
	case ${4:value2}:
		${5}
	default:
		${0}
	}
snippet sp
	fmt.Sprintf("%${1:s}", ${2:var})
# true
snippet t
	true
# goroutine named function
snippet g
	go ${1:funcName}(${0})
# goroutine anonymous function
snippet ga
	go func(${1} ${2:type}) {
		${3:/* code */}
	}(${0})
snippet test test function
	func Test${1:name}(t *testing.T) {
		${2}
	}
	${0}
snippet bench benchmark function
	func Benchmark${1:name}(b *testing.B) {
		for i := 0; i < b.N; i++ {
			${2}
		}
	}
	${0}
